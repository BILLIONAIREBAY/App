C'est reÃ§u, Admin ClÃ©ment.

J'ai analysÃ© le MASTER PROMPT "LUMINESCENCE V3". La mission est claire : Phygital Sovereignty. L'architecture est verrouillÃ©e : Local-First, Edge-Orchestrated, FxChain Native. Les rÃ¨gles sont absolues : Tabula Rasa, ZÃ©ro Placeholder, FxChain First.

Je passe immÃ©diatement en phase d'exÃ©cution. Initialisation de la structure Monorepo et des fondations techniques.

ðŸ—ï¸ TÃ‚CHE 0 : INITIALISATION DU SYSTÃˆME
Voici les commandes et fichiers que je gÃ©nÃ¨re pour structurer le projet sur Replit.

1. STRUCTURE DU MONOREPO & DÃ‰PENDANCES RACINES
CrÃ©ation de l'architecture dossier par dossier pour sÃ©parer les responsabilitÃ©s (Front, Back, Chain).

Bash

# CrÃ©ation de l'arborescence Luminescence
mkdir -p app            # Frontend React Native (Expo)
mkdir -p backend        # Cloudflare Workers + Supabase config
mkdir -p chain          # Hardhat + Smart Contracts FxChain
mkdir -p shared         # Types TypeScript partagÃ©s (tRPC)

# Initialisation du package.json racine (Workspaces)
cat > package.json <<EOF
{
  "name": "billionairebay-luminescence",
  "version": "3.0.0",
  "private": true,
  "workspaces": [
    "app",
    "backend",
    "chain",
    "shared"
  ],
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "chain:compile": "cd chain && npx hardhat compile",
    "db:push": "cd backend && supabase db push"
  },
  "devDependencies": {
    "turbo": "latest",
    "typescript": "^5.3.3",
    "prettier": "^3.2.5"
  }
}
EOF
2. CONFIGURATION BLOCKCHAIN (GHOST CHAIN / BASE SEPOLIA)
Configuration de l'environnement de dÃ©veloppement pour simuler la FxChain sur Base Sepolia.

Fichier : /chain/hardhat.config.ts

TypeScript

import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import * as dotenv from "dotenv";

dotenv.config();

const PRIVATE_KEY = process.env.PRIVATE_KEY || "";
const RPC_URL = process.env.NEXT_PUBLIC_RPC_URL || "https://sepolia.base.org";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200, // Optimisation pour les frais de la FxChain
      },
    },
  },
  networks: {
    // Configuration "Ghost Chain" (Dev Mode)
    baseSepolia: {
      url: RPC_URL,
      accounts: PRIVATE_KEY ? [PRIVATE_KEY] : [],
      chainId: 84532, // Base Sepolia ID
    },
    // Configuration "Sovereign" (Prod Mode - PrÃªt pour DÃ©cembre)
    fxChain: {
      url: "https://rpc.flowesome.com",
      accounts: PRIVATE_KEY ? [PRIVATE_KEY] : [],
      chainId: 77777,
    }
  },
  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts"
  }
};

export default config;
3. MIGRATIONS SQL SUPABASE (SOCLE DE DONNÃ‰ES)
CrÃ©ation du schÃ©ma initial supportant le "Living Asset" (JSONB) et la sÃ©curitÃ© (RLS).

Fichier : /backend/supabase/migrations/20240101000000_init_luminescence.sql

SQL

-- 1. TABLE USERS (IDENTITY CORE)
CREATE TABLE public.users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    username TEXT UNIQUE,
    wallet_address TEXT UNIQUE, -- Wallet FxChain (Account Abstraction)
    trust_score INT DEFAULT 100, -- Score de confiance (Aura Registry)
    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- SÃ©curitÃ© RLS : Un user ne peut modifier que son propre profil
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can update own profile" ON public.users
    FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Public read access" ON public.users
    FOR SELECT USING (true);


-- 2. TABLE ITEMS (LUXURY CATALOG & LIVING ASSET)
CREATE TYPE asset_category_enum AS ENUM ('physical', 'digital_asset', 'hybrid');
CREATE TYPE item_status_enum AS ENUM ('draft', 'active', 'auction_live', 'sold', 'stolen', 'frozen');

CREATE TABLE public.items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vendor_id UUID REFERENCES public.users(id) NOT NULL,
    
    -- DonnÃ©es de base
    title TEXT NOT NULL,
    description TEXT,
    
    -- Classification
    category asset_category_enum NOT NULL DEFAULT 'physical',
    status item_status_enum NOT NULL DEFAULT 'draft',
    
    -- LIVING ASSET DATA (Fx-721L Mirror)
    -- Stocke les donnÃ©es dynamiques : historique, maintenance, IoT, Zervos
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- SÃ‰CURITÃ‰ & AURA REGISTRY
    serial_number_hash TEXT, -- HashÃ© pour confidentialitÃ© avant vente
    fx_chain_token_id TEXT, -- Lien vers le NFT sur FxChain
    is_stolen_flag BOOLEAN DEFAULT FALSE, -- Sync avec Aura Registry
    
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexation pour la recherche rapide (Smart Lenses)
CREATE INDEX idx_items_metadata ON public.items USING gin (metadata);
CREATE INDEX idx_items_status ON public.items (status);

-- SÃ©curitÃ© RLS Items
ALTER TABLE public.items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read active items" ON public.items
    FOR SELECT USING (status IN ('active', 'auction_live', 'sold'));
CREATE POLICY "Vendor CRUD own items" ON public.items
    FOR ALL USING (auth.uid() = vendor_id);
4. CONFIGURATION SHADOW VAULT (CLOUDFLARE R2)
PrÃ©paration du bucket chiffrÃ© pour les preuves d'authenticitÃ© sensibles.

Fichier : /backend/wrangler.toml

Ini, TOML

name = "bbay-backend-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"

# Stockage "Shadow Vault" pour les certificats Zervos et preuves ZK
[[r2_buckets]]
binding = "SHADOW_VAULT"
bucket_name = "bbay-shadow-vault-encrypted"

# Base de donnÃ©es Edge (Ã‰tat des enchÃ¨res <10ms)
[[durable_objects]]
bindings = [
  { name = "AUCTION_ROOM", class_name = "AuctionRoomDO" }
]

[[migrations]]
tag = "v1"
new_classes = ["AuctionRoomDO"]
âœ… Ã‰TAT DE LA TÃ‚CHE 0 : TERMINÃ‰E
L'infrastructure Monorepo est en place. L'environnement Blockchain est configurÃ© sur Base Sepolia (prÃªt pour le switch FxChain). Le schÃ©ma Supabase est prÃªt Ã  accueillir les "Living Assets". Le Shadow Vault est dÃ©clarÃ©.

Ordres pour la suite (TASK 1) : Je suis prÃªt Ã  configurer WatermelonDB (Frontend) et le moteur de synchronisation pour garantir l'architecture Local-First.